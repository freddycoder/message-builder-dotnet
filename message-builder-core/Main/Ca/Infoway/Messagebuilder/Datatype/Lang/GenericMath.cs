/**
 * Copyright 2013 Canada Health Infoway, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author:        $LastChangedBy: gng $
 * Last modified: $LastChangedDate: 2015-11-19 18:20:12 -0500 (Fri, 30 Jan 2015) $
 * Revision:      $LastChangedRevision: 9755 $
 */


/// ---------------------------------------------------------------------------------------------------
///  This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
///  Version 1.0.0                                                                                      
/// ---------------------------------------------------------------------------------------------------
 
namespace Ca.Infoway.Messagebuilder.Datatype.Lang {
	
	using Ca.Infoway.Messagebuilder;
    using Ca.Infoway.Messagebuilder.Datatype.Lang;
    using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// A math utility class for operations on various datatypes.
	/// Currently supports Number types, PhysicalQuantity, and Date.
	/// </summary>
	///
	internal class GenericMath {
	
		/// <summary>
		/// Adds two values of the same type. 
		/// </summary>
		///
		/// <param name="T"> the type of the values to be added together.</param>
		/// <param name="low">first value to be added</param>
		/// <param name="width">second value to be added</param>
		/// <returns>the sum of the two values</returns>
		/// <exception cref="IllegalArgumentException if the type is not supported"/>
		public static T Add<T>(T low, T width) {
	
			if (low == null) {
				return width;
			} else if (width == null) {
				return low;
			} else if (low  is  Int32?) {
                return (T)(object)AddInteger((Int32?)(object)low, (Int32?)(object)width);
			} else if (low  is  Int64?) {
                return (T)(object)AddLong((Int64?)(object)low, (Int64?)(object)width);
			} else if (low  is  Double?) {
                return (T)(object)AddDouble((Double?)(object)low, (Double?)(object)width);
			} else if (low  is  BigDecimal) {
                return (T)(object)AddBigDecimal((BigDecimal)(object)low, (BigDecimal)(object)width);
			} else if (low  is  PhysicalQuantity) {
                return (T)(object)AddPhysicalQuantity((PhysicalQuantity)(object)low, (PhysicalQuantity)(object)width);
			} else if (low  is  PlatformDate) {
                return (T)(object)AddDate((PlatformDate)(object)low, (PlatformDate)(object)width);
            } else if (low is Money) {
                return (T)(object)AddMoney((Money)(object)low, (Money)(object)width);
			} else {
				throw new ArgumentException(
						"Can't determine how to perform addition on "
								+ low.GetType());
			}
		}
	
		private static PhysicalQuantity AddPhysicalQuantity(PhysicalQuantity q1,
				PhysicalQuantity q2) {
            // Units must be the same in order to be added (though an argument can be made that we 
            // could be smart about unit types that can be converted to each other).

            // Redmine 11271 - special case: if both units are null then the add will be allowed to go through as if the two values had the same units

            Boolean unitsBothNull = (q1.Unit == null && q2.Unit == null);
            Boolean unitsBothProvided = (q1.Unit != null && q2.Unit != null);
            if (unitsBothNull || (unitsBothProvided && StringUtils.Equals(q1.Unit.CodeValue, q2.Unit.CodeValue))) {
				return new PhysicalQuantity(Add(q1.Quantity, q2.Quantity), q1.Unit);
			} else {
                //Fix for exception msg.  Null Reference Exception otherwise.  
                string q1Units = (q1.Unit == null ? "" : q1.Unit.CodeValue);
                string q2Units = (q2.Unit == null ? "" : q2.Unit.CodeValue); 

				throw new ArgumentException(
						"Can't add two quantities of different units: "
								+ q1Units + " and " + q2Units);
			}
		}

        private static Money AddMoney(Money m1, Money m2) {
            // Currencies must be the same in order to be added
            if (ObjectUtils.Equals(m1.Currency, m2.Currency)) { // (null, null) = true
                return new Money(Add(m1.Amount, m2.Amount), m1.Currency);
            } else {
                String m1Currency = (m1.Currency == null ? "" : m1.Currency.CodeValue);
                String m2Currency = (m2.Currency == null ? "" : m2.Currency.CodeValue);
                throw new ArgumentException(
                        "Can't add two money values of different currencies: " + m1Currency +
                        " and " + m2Currency);
            }
        }
	
		/// <summary>
		/// Averages two values of the same type. 
		/// </summary>
		///
		/// <param name="T"> the type of the values to be added together.</param>
		/// <param name="low">first value to be added</param>
		/// <param name="high">second value to be added</param>
		/// <returns>the average of the two values</returns>
		/// <exception cref="IllegalArgumentException if the type is not supported"/>
		public static T Average<T>(T low, T high) {
			return Half(Add(low, high));
		}
	
		/// <summary>
		/// Calculates the differenced between two values of the same type. 
		/// </summary>
		///
		/// <param name="T"> the type of the values to be differenced.</param>
		/// <param name="t">first value to be differenced</param>
		/// <param name="t2">second value to be differenced</param>
		/// <returns>the diff of the two values</returns>
		/// <exception cref="IllegalArgumentException if the type is not supported"/>
		public static Diff<T> Diff<T>(T t, T t2) {
            if (t != null && t2 != null)
            {
                if (t is PlatformDate)
                {
                    return (Diff<T>)(object)DiffDate((PlatformDate)(object)t, (PlatformDate)(object)t2);
                }
                else if (t is Int64?)
                {
                    return (Diff<T>)(object)DiffLong((Int64?)(object)t, (Int64?)(object)t2);
                }
                else if (t is BigDecimal)
                {
                    return (Diff<T>)(object)DiffBigDecimal((BigDecimal)(object)t, (BigDecimal)(object)t2);
                }
                else if (t is Int32?)
                {
                    return (Diff<T>)(object)DiffInteger((Int32?)(object)t, (Int32?)(object)t2);
                }
                else if (t is PhysicalQuantity)
                {
                    return (Diff<T>)(object)DiffPhysicalQuantity((PhysicalQuantity)(object)t, (PhysicalQuantity)(object)t2);
                }
                else if (t is Money)
                {
                    return (Diff<T>)(object)DiffMoney((Money)(object)t, (Money)(object)t2);
                }
                else
                {
                    throw new ArgumentException(
                            "Can't determine how to perform diff on " + t.GetType());
                }
            }
            else
            {
                return null;
            }
        }
	
		private static Diff<PhysicalQuantity> DiffPhysicalQuantity(
				PhysicalQuantity q1, PhysicalQuantity q2) {
            Boolean unitsBothNull = (q1.Unit == null && q2.Unit == null);
            Boolean unitsBothProvided = (q1.Unit != null && q2.Unit != null);
            if (unitsBothNull || (unitsBothProvided && StringUtils.Equals(q1.Unit.CodeValue, q2.Unit.CodeValue)))
            {
                Diff<BigDecimal> diff = Diff(q1.Quantity, q2.Quantity);
                return diff == null ? null : new Diff<PhysicalQuantity>(new PhysicalQuantity(diff.Value, q1.Unit));
			} else {
				throw new ArgumentException(
						"Can't diff two quantities of different units: "
								+ q1.Unit + " and " + q2.Unit);
			}
		}

        private static Diff<Money> DiffMoney(Money q1, Money q2) {
            if (ObjectUtils.Equals(q1.Currency, q2.Currency)) { // (null, null) = true
                Diff<BigDecimal> diff = Diff(q1.Amount, q2.Amount);
                return diff == null ? null : new Diff<Money>(new Money(diff.Value, q1.Currency));
            } else {
                throw new ArgumentException(
                        "Can't diff two money values of different currencies: " + q1.Currency +
                        " and " + q2.Currency);
            }
        }
	
		private static Diff<BigDecimal> DiffBigDecimal(BigDecimal q1, BigDecimal q2) {
			return new Diff<BigDecimal>(q2.Subtract(q1));
		}
	
		private static Diff<Int32?> DiffInteger(Int32? integer1, Int32? integer2) {
			return new Diff<Int32?>(integer2 - integer1);
		}
	
		private static Diff<Int64?> DiffLong(Int64? long1, Int64? long2) {
			return new Diff<Int64?>(long2 - long1);
		}
	
		private static Diff<Ca.Infoway.Messagebuilder.PlatformDate> DiffDate(Ca.Infoway.Messagebuilder.PlatformDate date, Ca.Infoway.Messagebuilder.PlatformDate date2) {
			return new Diff<Ca.Infoway.Messagebuilder.PlatformDate>(new Ca.Infoway.Messagebuilder.PlatformDate(date2.Time - date.Time));
		}
	
		/// <summary>
		/// Halves a given value.
		/// </summary>
		///
		/// <param name="T"> the type of the value to be halved</param>
		/// <param name="t">the value to be halved</param>
		/// <returns>the halved value</returns>
		public static T Half<T>(T t) {
			if (t == null) {
				return  default/* was: null */;
			} else if (t  is  Int32?) {
                return (T)(object)Half((Int32?)(object)t);
			} else if (t  is  Int64?) {
                return (T)(object)Half((Int64?)(object)t);
			} else if (t  is  PlatformDate) {
                return (T)(object)Half((PlatformDate)(object)t);
			} else if (t  is  PhysicalQuantity) {
                return (T)(object)Half((PhysicalQuantity)(object)t);
            } else if (t is Money) {
                return (T)(object)Half((Money)(object)t);
            } else {
				return  default/* was: null */;
			}
		}
	
		private static Int32? Half(Int32? value_ren) {
			return (value_ren).Value / 2;
		}
	
		private static PhysicalQuantity Half(PhysicalQuantity value_ren) {
            BigDecimal quantity = value_ren.Quantity;
            BigDecimal newValue = quantity == null ? null : quantity.Multiply(new BigDecimal("0.5"));
            return new PhysicalQuantity(newValue, value_ren.Unit);
		}

        private static Money Half(Money value) {
            BigDecimal quantity = value.Amount;
            BigDecimal newValue = quantity == null ? null : quantity.Multiply(new BigDecimal("0.5"));
            return new Money(newValue, value.Currency);
        }
	
		private static Int64? Half(Int64? value_ren) {
			return (value_ren).Value / 2L;
		}
	
		private static Ca.Infoway.Messagebuilder.PlatformDate Half(Ca.Infoway.Messagebuilder.PlatformDate value_ren) {
			return new Ca.Infoway.Messagebuilder.PlatformDate(value_ren.Time / 2L);
		}
	
		private static BigDecimal AddBigDecimal(BigDecimal value1, BigDecimal value2) {
			return value1.Add(value2);
		}
	
		/// <summary>
		/// Adds a value to a diff of the same type. 
		/// </summary>
		///
		/// <param name="T"> the type of the values to be added together.</param>
		/// <param name="low">first value to be added</param>
		/// <param name="width">diff value to be added</param>
		/// <returns>the sum of the two values</returns>
		/// <exception cref="IllegalArgumentException if the type is not supported"/>
		public static T Add<T>(T low, Diff<T> width) {
            if (width == null || width.Value == null) {
                return low;
            } else if (low == null) {
                return width.Value;
            } else if (low is PlatformDate && width is DateDiff) {
                return (T)(object)AddDate((PlatformDate)(object)low, (DateDiff)(object)width);
			} else if (low  is  PlatformDate) {
                return (T)(object)AddDate((Ca.Infoway.Messagebuilder.PlatformDate)(object)low, (Diff<Ca.Infoway.Messagebuilder.PlatformDate>)(object)width);
			} else {
				return Add(low, width.Value);
			}
		}
	
		private static Ca.Infoway.Messagebuilder.PlatformDate AddDate(Ca.Infoway.Messagebuilder.PlatformDate date, DateDiff diff) {
			if (diff.UnitValue == null || diff.Unit == null) {
				return AddDate(date, (Diff<Ca.Infoway.Messagebuilder.PlatformDate>) diff);
			} else {
                DateTime dt = date;

                if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.SECOND.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddSeconds((double)(diff.UnitValue.Value));
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.MINUTE.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddMinutes((double)(diff.UnitValue.Value));
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.HOUR.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddHours((double)(diff.UnitValue.Value));
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.DAY.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddDays((double)(diff.UnitValue.Value));
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.WEEK.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddDays((double)(diff.UnitValue.Value * 7));
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.MONTH.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddMonths(diff.UnitValue.Value);
                }
                else if (Ca.Infoway.Messagebuilder.Datatype.Lang.DateDiff.YEAR.Equals(diff.Unit.CodeValue)) {
                    dt = dt.AddYears(diff.UnitValue.Value);
                }

                return new Ca.Infoway.Messagebuilder.PlatformDate(dt);
			}
		}
	
		private static Ca.Infoway.Messagebuilder.PlatformDate AddDate(Ca.Infoway.Messagebuilder.PlatformDate date, Diff<Ca.Infoway.Messagebuilder.PlatformDate> diff) {
			return new Ca.Infoway.Messagebuilder.PlatformDate(date.Time + diff.Value.Time);
		}
	
		private static Ca.Infoway.Messagebuilder.PlatformDate AddDate(Ca.Infoway.Messagebuilder.PlatformDate date, Ca.Infoway.Messagebuilder.PlatformDate date2) {
			return new Ca.Infoway.Messagebuilder.PlatformDate(date.Time + date2.Time);
		}
	
		private static Double? AddDouble(Double? low, Double? width) {
			return low + width;
		}
	
		private static Int64? AddLong(Int64? low, Int64? width) {
			return low + width;
		}
	
		private static Int32? AddInteger(Int32? low, Int32? width) {
			return low + width;
		}
	}
}
